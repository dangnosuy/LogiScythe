# LogiScythe - exploiter.py
# Author: dangnosuy (Dang) & Gemini
# Refactored to use requests library and support flow-based testing

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
from typing import List, Dict, Any, Optional
import re
import json

# Suppress SSL warnings
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)


class Exploiter:
    """
    The Exploiter executes test cases against the target application.
    Supports both single requests and multi-step flow testing.
    """
    def __init__(self, cookies: List[Dict[str, Any]], target_domain: str, timeout: int = 30):
        print("[Exploiter] Initialized Exploiter.")
        self.cookies = cookies
        self.target_domain = target_domain
        self.timeout = timeout
        self.session = requests.Session()
        self.session.verify = False  # Ignore SSL errors
        self._setup_cookies()
        
    def _setup_cookies(self):
        """Setup cookies in the session."""
        if not self.cookies:
            return
        for cookie in self.cookies:
            self.session.cookies.set(
                cookie.get('name', ''),
                cookie.get('value', ''),
                domain=cookie.get('domain', self.target_domain),
                path=cookie.get('path', '/')
            )
        cookie_names = [c.get('name') for c in self.cookies]
        print(f"[Exploiter] Session cookies: {cookie_names}")

    def _build_url(self, path: str) -> str:
        """Build full URL from path."""
        if path.startswith(('http://', 'https://')):
            return path
        # Ensure path starts with /
        if not path.startswith('/'):
            path = '/' + path
        return f"https://{self.target_domain}{path}"

    def execute_request(self, step: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute a single HTTP request step.
        
        Step format:
        {
            "method": "POST",
            "path": "/cart/add",
            "headers": {"Content-Type": "application/json"},
            "body": {"productId": "1", "quantity": -1},
            "description": "Test negative quantity"
        }
        """
        method = (step.get('method') or 'GET').upper()
        path = step.get('path') or step.get('url') or '/'
        url = self._build_url(path)
        headers = step.get('headers') or {}
        body = step.get('body')
        description = step.get('description') or ''
        
        # Handle body - convert dict to appropriate format
        data = None
        json_body = None
        if body:
            content_type = headers.get('Content-Type', headers.get('content-type', ''))
            if isinstance(body, dict):
                if 'json' in content_type.lower() or not content_type:
                    json_body = body
                else:
                    data = body
            elif isinstance(body, str):
                data = body
        
        result = {
            "step": step,
            "request": {
                "method": method,
                "url": url,
                "headers": headers,
                "body": body
            },
            "response": {
                "status": None,
                "headers": {},
                "body": None,
                "error": None
            }
        }
        
        try:
            print(f"[Exploiter] {method} {url}")
            if description:
                print(f"           → {description}")
            
            resp = self.session.request(
                method=method,
                url=url,
                headers=headers,
                data=data,
                json=json_body,
                timeout=self.timeout,
                allow_redirects=True
            )
            
            result["response"]["status"] = resp.status_code
            result["response"]["headers"] = dict(resp.headers)
            result["response"]["body"] = resp.text[:5000] if resp.text else ""  # Truncate for LLM
            result["response"]["final_url"] = resp.url
            
            print(f"           ← Status: {resp.status_code}")
            
        except requests.Timeout:
            result["response"]["error"] = "Request timed out"
            print(f"           ← ERROR: Timeout")
        except requests.RequestException as e:
            result["response"]["error"] = str(e)
            print(f"           ← ERROR: {e}")
        except Exception as e:
            result["response"]["error"] = f"Unexpected error: {e}"
            print(f"           ← ERROR: {e}")
            
        return result

    def execute_flow(self, flow: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute a multi-step flow test.
        
        Flow format:
        {
            "name": "Skip cart step",
            "description": "Test if user can checkout without adding to cart",
            "steps": [
                {"method": "GET", "path": "/product/1"},
                {"method": "POST", "path": "/checkout", "body": {"productId": "1"}}
            ]
        }
        """
        name = flow.get('name', 'Unnamed flow')
        description = flow.get('description', '')
        steps = flow.get('steps', [])
        
        print(f"\n{'='*50}")
        print(f"[Flow Test] {name}")
        print(f"           {description}")
        print(f"           Steps: {len(steps)}")
        print(f"{'='*50}")
        
        # Create fresh session for each flow to avoid state pollution
        self.session = requests.Session()
        self.session.verify = False
        self._setup_cookies()
        
        results = {
            "flow_name": name,
            "flow_description": description,
            "step_results": [],
            "success": True
        }
        
        for i, step in enumerate(steps, 1):
            print(f"\n[Step {i}/{len(steps)}]")
            step_result = self.execute_request(step)
            results["step_results"].append(step_result)
            
            # Check if step failed critically
            if step_result["response"]["error"]:
                results["success"] = False
                print(f"[!] Flow error at step {i}: {step_result['response']['error']}")
                # Continue anyway to see what happens
        
        # Determine overall success based on last step's response
        last_result = results["step_results"][-1] if results["step_results"] else None
        if last_result:
            last_status = last_result["response"].get("status")
            # Consider success if we got a response (even if error status)
            results["success"] = last_status is not None
        
        print(f"\n[Flow Complete] {name}")
        return results

    def run_single_attack(self, command_or_payload: Any) -> Dict[str, Any]:
        """
        Adapter method to support the iterative loop.
        Accepts either a curl command string (legacy/fallback) or a structured request dict.
        """
        if isinstance(command_or_payload, str):
            # If it's a string, it might be a curl command.
            # Since we want to avoid curl, we should ideally parse it, but for now
            # let's assume the AI is providing JSON as requested.
            try:
                payload = json.loads(command_or_payload)
            except json.JSONDecodeError:
                # Fallback: if it's not JSON, return error or try to execute as is (not supported)
                return {
                    "command": command_or_payload,
                    "stdout": "",
                    "stderr": "Error: Expected JSON payload for requests, got raw string/curl command."
                }
        else:
            payload = command_or_payload

        # Execute using requests
        result = self.execute_request(payload)
        
        # Format output to match what the iterative loop expects (stdout/stderr)
        response = result.get("response", {})
        status = response.get("status")
        body = response.get("body", "")
        error = response.get("error")
        
        stdout = f"HTTP Status: {status}\nBody:\n{body}"
        stderr = error if error else ""
        
        return {
            "command": json.dumps(payload), # Store the JSON payload as the "command"
            "stdout": stdout,
            "stderr": stderr
        }
