# LogiScythe - exploiter.py
# Author: dangnosuy (Dang) & Gemini

import subprocess
import shlex
from typing import List, Dict, Any
import re

class Exploiter:
    """
    The Exploiter takes the attack payloads (curl commands) suggested by the AI
    and executes them to test the potential vulnerabilities.
    """
    def __init__(self, cookies: List[Dict[str, Any]], target_domain: str):
        print("[Exploiter] Initialized Exploiter.")
        self.cookies = cookies
        self.target_domain = target_domain
        self.cookie_string = self._format_cookies()
        print(f"[Exploiter] Formatted cookie string for use: '{self.cookie_string}'")

    def _format_cookies(self) -> str:
        """Converts the cookie list from Playwright into a string for curl."""
        if not self.cookies:
            return ""
        return "; ".join([f"{cookie['name']}={cookie['value']}" for cookie in self.cookies])

    def _prepare_command(self, command_template: str) -> str:
        """Replaces placeholders and corrects common AI mistakes in the command."""
        
        command = command_template # Start with the original template

        # --- Fix common AI generation errors before placeholder replacement ---

        # 1. Proactively fix potential cookie duplication.
        # The AI might generate "session={session_cookie}" which becomes "session=session=value".
        # We'll replace "session={session_cookie}" with just "{session_cookie}" first.
        # This handles cases in both --cookie flags and -H 'Cookie: ...' headers.
        command = re.sub(r'session\s*=\s*\{session_cookie\}', '{session_cookie}', command, flags=re.IGNORECASE)
        
        # 2. Force HTTPS for the target domain to avoid "not accessible over HTTP"
        http_domain_url = f"http://{self.target_domain}"
        if http_domain_url in command:
            print(f"[Exploiter] Warning: Command uses HTTP for target domain. Forcing HTTPS.")
            https_domain_url = f"https://{self.target_domain}"
            command = command.replace(http_domain_url, https_domain_url)

        # --- Replace placeholders ---
        command = command.replace("{target_domain}", self.target_domain)
        command = command.replace("{session_cookie}", self.cookie_string)
        
        return command

    def run_attacks(self, attack_payloads: List[str]) -> List[Dict[str, str]]:
        """
        Executes a list of curl commands and returns their results.
        """
        if not attack_payloads:
            print("[Exploiter] No attack payloads to execute.")
            return []

        execution_results = []

        for i, payload_template in enumerate(attack_payloads):
            
            final_command = self._prepare_command(payload_template)
            
            print("\n" + "-"*10 + f" Executing Attack Payload #{i+1} " + "-"*10)
            print(f"[Exploiter] Command: {final_command}")
            
            result = {
                "command": final_command,
                "stdout": "",
                "stderr": ""
            }

            try:
                # Use shlex.split to handle command line arguments safely
                args = shlex.split(final_command)
                
                # Execute the command
                # We add -i to include headers in the output
                if 'curl' in args and '-i' not in args:
                    args.insert(1, '-i')

                process = subprocess.run(
                    args,
                    capture_output=True,
                    text=True,
                    timeout=30 # 30-second timeout
                )
                
                print("[Exploiter] Execution complete. Results:")
                print("\n--- STDOUT ---")
                print(process.stdout if process.stdout else "(empty)")
                print("\n--- STDERR ---")
                print(process.stderr if process.stderr else "(empty)")
                print("--------------")

                result["stdout"] = process.stdout
                result["stderr"] = process.stderr

            except FileNotFoundError:
                error_msg = "[!] Error: 'curl' command not found. Please ensure curl is installed and in your PATH."
                print(error_msg)
                result["stderr"] = error_msg
                execution_results.append(result)
                break 
            except subprocess.TimeoutExpired:
                error_msg = "[!] Error: Command timed out after 30 seconds."
                print(error_msg)
                result["stderr"] = error_msg
            except Exception as e:
                error_msg = f"[!] An unexpected error occurred while running the command: {e}"
                print(error_msg)
                result["stderr"] = error_msg
            
            execution_results.append(result)
        
        return execution_results

    def run_single_attack(self, command: str) -> Dict[str, str]:
        """
        Execute a single curl command and return its result.
        Used by iterative testing loop.
        """
        final_command = self._prepare_command(command)
        
        result = {
            "command": final_command,
            "stdout": "",
            "stderr": ""
        }

        try:
            args = shlex.split(final_command)
            
            if 'curl' in args and '-i' not in args:
                args.insert(1, '-i')

            process = subprocess.run(
                args,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            result["stdout"] = process.stdout
            result["stderr"] = process.stderr

        except FileNotFoundError:
            result["stderr"] = "[!] Error: 'curl' command not found."
        except subprocess.TimeoutExpired:
            result["stderr"] = "[!] Error: Command timed out after 30 seconds."
        except Exception as e:
            result["stderr"] = f"[!] Error: {e}"
        
        return result

# Example usage (for testing this file directly)
if __name__ == '__main__':
    print("[+] Running exploiter.py in standalone test mode.")
    
    # Dummy data similar to what would be passed from main.py
    dummy_cookies = [{'name': 'session', 'value': 'abc123xyz'}]
    dummy_domain = "httpbin.org" # Using httpbin.org for safe testing
    
    # Dummy payloads from the AI
    dummy_payloads = [
        "curl -X POST -b '{session_cookie}' -H 'Content-Type: application/json' -d '{\"price\": -100}' https://{target_domain}/post",
        "curl -X GET 'https://{target_domain}/get?user_id=123'"
    ]
    
    exploiter = Exploiter(cookies=dummy_cookies, target_domain=dummy_domain)
    exploiter.run_attacks(dummy_payloads)
